# Viterbi-Algorithm
This is about the implementation of (2,1,4) Convolutional Encoder and Viterbi Decoder using Verilog VHDL. 

## *Why Viterbi Algorithm?*

Convolutional coding is a coding scheme used in communication systems including deep space communications and wireless communications. It provides an alternative approach to block codes for transmission over a noisy channel. The block codes can be applied only for the block of data. The convolutional coding has an advantage over the block codes in that it can be applied to a continuous data stream as well as to blocks of data. IS-95, a wireless digital cellular standard for CDMA (Code Division Multiple Access), employs convolutional coding. A third generation wireless cellular standard, under preparation, plans to adopt turbo coding, which stems from the convolutional coding. The Viterbi decoding algorithm was proposed and analyzed by Viterbi in 1967. It is widely used as a decoding technique for convolutional codes as well as the bit detection method in storage devices. Viterbi decoders currently find their use in more than one billion cell phones. The algorithm works by forming trellis structure, which is eventually traced back for decoding the received information. Convolutional encoding with Viterbi decoding is a powerful method for forward error correction. The Viterbi algorithm essentially performs maximum likelihood decoding. However, it reduces the computational complexity by using trellis structure. Below Figure shows the convolutional encoder and Viterbi decoder, which is used in the digital communication system. Here, X is the input data steam, which is given into the convolutional encoder and it produces the encoded data stream (Y). The encoded data stream (Y) is given to the channel in the presence of noise. Hence, it produces the noise added encoded data stream (R). Finally, data stream (R) is given to the Viterbi decoder that produces the estimated data stream (Z) applied at the input.

![algovit](https://user-images.githubusercontent.com/65102010/90029266-4e202e80-dcd8-11ea-8a0a-b88a77d66ee7.png)

## *Convolutional Encoder*

Convolutional codes are very suitable to protecting the digital data transmission from random errors due to any noise source. It achieves error free transmission by adding sufficient redundancy to the source symbols. Convolutional codes are usually described using two parameters: the code rate and the constraint length. The code rate is expressed as a ratio of number of input symbols (k) into the channel encoder to the number of output symbols (n) by the channel encoder in a given cycle. Then, the code rate is expressed as, r = k/n bits/symbol The constraint length (K) denotes the length of the convolutional encoder. Convolutional encoder increases the length of the message sequence by adding redundant bits in order to increase the likelihood of detecting the transmitted sequence even if errors have occurred during transmission. Below Figure shows the convolutional encoder of constraint length (K) = 7 and code rate (r) = 1/2. A convolutional encoder generates redundant bits by using modulo-2 convolutions. Hence, it is called as Convolutional encoder. If n modulo-2 adders are used, then it produces n outputs for each bit. 

![encoder](https://user-images.githubusercontent.com/65102010/90027487-38116e80-dcd6-11ea-8d00-7995bf7681de.png)
